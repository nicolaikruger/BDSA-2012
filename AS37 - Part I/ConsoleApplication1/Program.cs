using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Collections;
using System.Text.RegularExpressions;

namespace BDSA12
{
	class Program
	{
		// Two "standard" regular expressions that are used later in the program
		private static string urlRegEx = @"(http://|www|http://www)[\.\w\d-_]*\.\w*[^\s]*";
		private static string dateRegEx = @"(?<=Posted: )\w+, \d+ \w+ \d+";

		private static string txt = "";
		private static string Txt
		{
			get { return txt; }
			set	{ if(txt.Equals("")) txt = value; }
		}

		static void Main(string[] args)
		{
			Txt = TextFileReader.ReadFile("../../testFile.txt");

			// Makes a searh with a string that ain't in the docuemnt.
			// We are doing this to print out the whole document with colors (dates and URIs)
			search("String that cant be found in the txt!");

			// Read input - There is no command to close the program (yet)
			while (true)
			{
				string input = Console.ReadLine();
				if (input.Length > 0)
				{
					Console.Clear();
					search(input);
				}
			}
		}

		/// <summary>
		/// Initiate a search in the document for the specified keyword(s).
		/// After the search the document will be printet in the console, with URIs, dates and the keyword(s) highlighted - in diffenrent colors
		/// </summary>
		/// <param name="keyword">A string representing what the program should highligt in the document</param>
		static void search(string keyword)
		{
			string expression = removePluses(keyword);

			Console.Out.WriteLine("You searched for: \"" + expression + "\"\n");

			List<Tuple<int, int>> matchesIndexes = getIndexes(Txt, expression);

			createStringParts(matchesIndexes);
		}
		
		/// <summary>
		/// "Splits" a given string up acording to a given regularexpression. Finds the indexs of where the matches of the RegEx starts and ends
		/// </summary>
		/// <param name="txt">The text to search in</param>
		/// <param name="expression">The regularexpression to searh for</param>
		/// <returns>
		/// A list of tuples. 
		/// The first value in a tuple tells at what index in the given string a match occur.
		/// The second value tells at what index the same match ends.
		/// The first tuple will be the first match, the second tuple the second match and so forth.</returns>
		static List<Tuple<int, int>> getIndexes(string txt, string expression)
		{
			List<Tuple<int, int>> returnList = new List<Tuple<int, int>>();

			Regex reg = new Regex(expression);
			MatchCollection matches = reg.Matches(txt);

			foreach (Match match in matches)
			{
				int startIndex = match.Index;
				int length = match.Length;
				returnList.Add(new Tuple<int, int>(startIndex, startIndex + length));
			}

			return returnList;
		}

		/// <summary>
		/// This is the first part of the seacrh.
		/// It splits up the document into stringParts acording to the a list of Tuples generated by the <see cref="getIndexes"/> method.
		/// If a date og URI is to be found in a "non-matcing" string, that string will be splitted into stringparts by the <see cref="findURL"/> and/or <see cref="findDates"/> methods.
		/// On completion, all of the stringParts will be printed out to the console, with their respective colors by the <see cref="print"/> method.
		/// </summary>
		/// <param name="list">A list of tuples - genrated by the <see cref="getIndexes"/> method.</param>
		static void createStringParts(List<Tuple<int, int>> list)
		{
			int normalStartIndex = 0;
			List<StringPart> stringParts = new List<StringPart>();

			foreach (Tuple<int, int> t in list)
			{
				if (t.Item1 != normalStartIndex) {
					string normalTxt = Txt.Substring(normalStartIndex, (t.Item1 - normalStartIndex));
					if (Regex.IsMatch(normalTxt, urlRegEx))
						stringParts.AddRange(findURL(normalTxt, normalStartIndex));
					else if(Regex.IsMatch(normalTxt, dateRegEx))
						stringParts.AddRange(findDates(normalTxt, normalStartIndex));
					else
						stringParts.Add(new StringPart(normalTxt, ConsoleColor.Black));
				}

				int length = t.Item2 - t.Item1;
				string keyWordTxt = Txt.Substring(t.Item1, length);
				stringParts.Add(new StringPart(keyWordTxt, ConsoleColor.Yellow));
				normalStartIndex = t.Item2;
			}

			if (normalStartIndex != Txt.Length - 1) {
				int length = (Txt.Length - 1) - normalStartIndex;
				string normalTxt = Txt.Substring(normalStartIndex, length);
				if (Regex.IsMatch(normalTxt, urlRegEx))
					stringParts.AddRange(findURL(normalTxt, normalStartIndex));
				else if (Regex.IsMatch(normalTxt, dateRegEx))
					stringParts.AddRange(findDates(normalTxt, normalStartIndex));
				else
					stringParts.Add(new StringPart(normalTxt, ConsoleColor.Black));
			}

			print(stringParts.ToArray());
		}

		/// <summary>
		/// Splits the given string into stringparts of URIs, dates and "normal" text.
		/// </summary>
		/// <param name="txt">The string to split into stringParts</param>
		/// <param name="startIndex">The start index of the string within the document</param>
		/// <returns>The given text splitted into stringPart (URIs, dates and "normal" text)</returns>
		static List<StringPart> findURL(string txt, int startIndex)
		{
			int normalStartIndex = 0;
			List<StringPart> returnList = new List<StringPart>();
			List<Tuple<int, int>> indexList = getIndexes(txt, urlRegEx);

			foreach (Tuple<int, int> t in indexList)
			{
				if (t.Item1 != normalStartIndex)
				{
					string normalTxt = txt.Substring(normalStartIndex, (t.Item1 - normalStartIndex));
					if (Regex.IsMatch(normalTxt, dateRegEx))
						returnList.AddRange(findDates(normalTxt, normalStartIndex + startIndex));
					else
						returnList.Add(new StringPart(normalTxt, ConsoleColor.Black));
				}

				int length = t.Item2 - t.Item1;
				string keyWordTxt = txt.Substring(t.Item1, length);
				returnList.Add(new StringPart(keyWordTxt, ConsoleColor.Blue));
				normalStartIndex = t.Item2;
			}

			if (normalStartIndex != Txt.Length - 1)
			{
				int length = txt.Length - normalStartIndex;
				string normalTxt = txt.Substring(normalStartIndex, length);
				if (Regex.IsMatch(normalTxt, dateRegEx))
					returnList.AddRange(findDates(normalTxt, normalStartIndex));
				else
					returnList.Add(new StringPart(normalTxt, ConsoleColor.Black));
			}

			return returnList;
		}


		/// <summary>
		/// Splits the given string into stringparts of dates and "normal" text.
		/// </summary>
		/// <param name="txt">The string to split into stringParts</param>
		/// <param name="startIndex">The start index of the string within the document</param>
		/// <returns>The given text splitted into stringPart (dates and "normal" text)</returns>
		static List<StringPart> findDates(string txt, int startIndex)
		{
			int normalStartIndex = 0;
			List<StringPart> returnList = new List<StringPart>();
			List<Tuple<int, int>> indexList = getIndexes(txt, dateRegEx);

			foreach (Tuple<int, int> t in indexList)
			{
				if (t.Item1 != normalStartIndex)
				{
					string normalTxt = txt.Substring(normalStartIndex, (t.Item1 - normalStartIndex));
					returnList.Add(new StringPart(normalTxt, ConsoleColor.Black));
				}

				int length = t.Item2 - t.Item1;
				string keyWordTxt = txt.Substring(t.Item1, length);
				returnList.Add(new StringPart(keyWordTxt, ConsoleColor.Red));
				normalStartIndex = t.Item2;
			}

			if (normalStartIndex != Txt.Length - 1)
			{
				int length = txt.Length - normalStartIndex;
				string normalTxt = txt.Substring(normalStartIndex, length);
				returnList.Add(new StringPart(normalTxt, ConsoleColor.Black));
			}

			return returnList;
		}

		/// <summary>
		/// Prints the given StringParts to the console with their respective colors.
		/// </summary>
		/// <param name="stringParts">The stringparts to be writtin</param>
		static void print(params StringPart[] stringParts)
		{
			Console.ForegroundColor = ConsoleColor.Gray;
			foreach (StringPart stringPart in stringParts)
			{
				Console.BackgroundColor = stringPart.color;
				Console.Out.Write(stringPart.txt);
			}

			Console.BackgroundColor = ConsoleColor.Black;
		}

		/// <summary>
		/// Removes any plusses ("+") from the given string and replaces them with a whitespaces
		/// </summary>
		/// <param name="s">The string to remove plusses ("+") from.</param>
		/// <returns>Returns the given string, but with the plusses ("+") converted into whitespaces</returns>
		static string removePluses(string s)
		{
			Regex reg = new Regex(@"\s*\+\s*");
			return removeStars(reg.Replace(s, @"\s"));
		}

		/// <summary>
		/// Converts the givin string, so that a star ("*") will match any alphabetic and/or digit characters.
		/// </summary>
		/// <param name="s">The string to remove a star ("*") from.</param>
		/// <returns>The given string, but with the star ("*") converted into regularexpression matching any alphabetic and/or digit characters.</returns>
		static string removeStars(string s)
		{
			Regex reg = new Regex(@"\*");
			return @"[^\d\w]" + reg.Replace(s, @"(\d|\w)*") + @"[^\d\w]";
		}

	}
}
